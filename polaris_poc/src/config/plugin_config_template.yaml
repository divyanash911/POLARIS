# POLARIS Plugin Configuration Template
# =====================================
# This template provides a standardized structure for POLARIS plugin configurations.
# Copy this template to your plugin directory as 'config.yaml' and customize for your system.
#
# Configuration Validation:
# This configuration is validated against managed_system.schema.json
# Ensure all required fields are present and follow the specified formats.
#
# Framework Integration:
# - Plugin configs are loaded by POLARIS adapters during initialization
# - Configuration errors will prevent plugin loading and system startup
# - Use environment variables for sensitive data (passwords, API keys)
#
# Documentation Standards:
# - Include comprehensive comments explaining each configuration section
# - Provide examples for different deployment environments
# - Document the relationship between settings and system behavior
# - Add validation guidance and common error patterns

# =============================================================================
# System Identification and Metadata
# =============================================================================
# Basic information about the managed system and plugin implementation.
# This section is required and used by POLARIS for plugin discovery and loading.

# Unique identifier for the managed system
# Must be unique across all plugins in a POLARIS deployment
# Use lowercase, alphanumeric characters and underscores only
# Examples: "web_server", "database_cluster", "load_balancer"
system_name: "example_system"

# Version of the plugin implementation
# Use semantic versioning (major.minor.patch) for compatibility tracking
# Update when plugin capabilities or interfaces change
system_version: "1.0.0"

# =============================================================================
# Implementation Configuration
# =============================================================================
# Defines how POLARIS connects to and interacts with the managed system.
# This section configures the connector class and communication parameters.

implementation:
  # Python class that implements the system connector interface
  # Must be importable from the plugin directory
  # Class should inherit from appropriate POLARIS base connector class
  # Format: "module.ClassName" (e.g., "connector.MySystemConnector")
  connector_class: "connector.ExampleConnector"
  
  # Connection timeout in seconds for system operations
  # Balance between allowing slow operations and preventing hangs
  # Recommended: 10-60 seconds depending on system characteristics
  timeout: 30.0
  
  # Maximum number of retry attempts for failed operations
  # Higher values increase reliability but may delay error detection
  # Recommended: 1-5 retries for most systems
  max_retries: 3

# =============================================================================
# Connection Configuration
# =============================================================================
# Network and authentication settings for connecting to the managed system.
# Customize based on your system's communication requirements.

connection:
  # Communication protocol used to connect to the system
  # Common values: "tcp", "http", "https", "grpc", "ssh", "snmp"
  # Must be supported by the connector implementation
  protocol: "tcp"
  
  # Hostname or IP address of the managed system
  # Use environment variables for deployment flexibility
  # Examples: "localhost", "system.example.com", "${SYSTEM_HOST}"
  host: "localhost"
  
  # Port number for system communication
  # Use standard ports when possible, document custom ports
  # Consider firewall and security implications
  port: 8080
  
  # Authentication configuration
  auth:
    # Authentication type supported by the system
    # Common values: "none", "basic", "token", "oauth", "certificate"
    type: "none"
    
    # Authentication credentials (use environment variables for security)
    # Examples:
    # username: "${SYSTEM_USERNAME}"
    # password: "${SYSTEM_PASSWORD}"
    # token: "${SYSTEM_API_TOKEN}"
    # certificate_path: "/path/to/cert.pem"
  
  # SSL/TLS configuration for secure connections
  ssl:
    # Enable SSL/TLS encryption
    # Always use true for production deployments
    enabled: false
    
    # SSL certificate verification
    # Set to false only for development with self-signed certificates
    verify_certificates: true
    
    # Custom certificate authority file path (optional)
    # ca_file: "/path/to/ca.pem"

# =============================================================================
# Monitoring Configuration
# =============================================================================
# Defines what metrics to collect from the managed system and how to collect them.
# This section is critical for POLARIS's adaptive capabilities.

monitoring:
  # Enable monitoring for this system
  # Set to false to disable metric collection (not recommended for production)
  enabled: true
  
  # Monitoring interval in seconds
  # Balance between data freshness and system load
  # Recommended: 1-60 seconds depending on system dynamics
  interval: 5.0
  
  # Metric definitions - each metric represents a measurable system property
  metrics:
    # Example performance metric
    - name: "response_time"
      # Command or method to retrieve the metric value
      # Format depends on connector implementation
      command: "get_response_time"
      
      # Unit of measurement for the metric value
      # Use standard units when possible (ms, seconds, bytes, percent, count)
      unit: "ms"
      
      # Data type of the metric value
      # Supported types: "float", "integer", "string", "boolean"
      type: "float"
      
      # Human-readable description of what this metric measures
      # Include context about what values indicate good/bad system state
      description: "Average response time for system requests"
      
      # Metric category for organization and analysis
      # Common categories: "performance", "resource", "availability", "quality"
      category: "performance"
    
    # Example resource metric
    - name: "cpu_usage"
      command: "get_cpu_usage"
      unit: "percent"
      type: "float"
      description: "Current CPU utilization percentage"
      category: "resource"
    
    # Example availability metric
    - name: "active_connections"
      command: "get_active_connections"
      unit: "count"
      type: "integer"
      description: "Number of currently active client connections"
      category: "availability"
  
  # Derived metrics - calculated from base metrics using formulas
  # Useful for creating composite indicators and normalized values
  derived_metrics:
    - name: "performance_index"
      # Formula using metric names as variables
      # Supports basic arithmetic operations (+, -, *, /, parentheses)
      formula: "100 - (response_time / 10 + cpu_usage)"
      unit: "index"
      description: "Composite performance index (higher is better)"
  
  # Monitoring strategy configuration
  strategies:
    # Collect multiple metrics in a single batch operation
    # true: More efficient but may fail if any metric fails
    # false: Individual metric collection, more resilient
    batch_collection: true
    
    # Collect metrics in parallel threads
    # true: Faster collection but higher resource usage
    # false: Sequential collection, lower resource usage
    parallel_collection: false
    
    # Maximum number of concurrent metric collection operations
    # Only relevant when parallel_collection is true
    max_concurrent: 1
    
    # Error handling strategy for failed metric collection
    # "fail": Stop monitoring if any metric fails
    # "skip": Continue monitoring, skip failed metrics
    # "retry": Retry failed metrics according to max_retries setting
    error_handling: "skip"

# =============================================================================
# Execution Configuration
# =============================================================================
# Defines what control actions can be performed on the managed system.
# This enables POLARIS to adapt the system based on monitoring data and analysis.

execution:
  # Enable execution capabilities for this system
  # Set to false to make the system read-only (monitoring only)
  enabled: true
  
  # Available actions that can be performed on the system
  actions:
    # Example scaling action
    - type: "SCALE_UP"
      # Command or method to execute the action
      # May include parameter placeholders (e.g., {count}, {value})
      command: "scale_up {count}"
      
      # Human-readable description of what this action does
      description: "Increase system capacity by adding resources"
      
      # Action parameters that can be specified when executing
      parameters:
        - name: "count"
          type: "integer"
          required: true
          # Parameter validation rules
          validation:
            min: 1
            max: 10
      
      # Preconditions that must be met before executing the action
      # Helps prevent unsafe operations
      preconditions:
        - check: "cpu_usage < 90"
          message: "Cannot scale up: CPU usage too high, may indicate other issues"
      
      # Impact assessment for the action
      impact:
        # Severity level of the action's impact on the system
        # "low": Minimal impact, safe to execute automatically
        # "medium": Moderate impact, may require approval
        # "high": Significant impact, requires careful consideration
        severity: "medium"
        
        # Whether the action can be reversed or undone
        # true: Action can be safely reversed (e.g., scale down after scale up)
        # false: Action is permanent or difficult to reverse
        reversible: true
        
        # Estimated time for the action to complete (seconds)
        # Used for planning and timeout configuration
        estimated_duration: 30.0
    
    # Example configuration action
    - type: "ADJUST_TIMEOUT"
      command: "set_timeout {value}"
      description: "Adjust system timeout configuration"
      parameters:
        - name: "value"
          type: "float"
          required: true
          validation:
            min: 1.0
            max: 300.0
      impact:
        severity: "low"
        reversible: true
        estimated_duration: 5.0
  
  # Execution constraints and safety limits
  constraints:
    # Minimum interval between actions (seconds)
    # Prevents rapid-fire actions that could destabilize the system
    min_interval: 10.0
    
    # Maximum number of concurrent actions
    # Most systems should serialize actions to prevent conflicts
    max_concurrent: 1
    
    # Maximum number of queued actions
    # Prevents unbounded queue growth during high adaptation activity
    queue_size: 100

# =============================================================================
# Plugin Metadata and Documentation
# =============================================================================
# Additional information about the plugin for documentation and management.

metadata:
  # Plugin author or maintainer information
  author: "Your Name or Organization"
  
  # Detailed description of the managed system and plugin capabilities
  description: "Example plugin template for POLARIS managed system integration"
  
  # Link to system documentation or plugin repository
  documentation: "https://github.com/your-org/your-plugin"
  
  # Tags for categorizing and searching plugins
  tags:
    - "example"
    - "template"
    - "web-service"

# =============================================================================
# Common Configuration Patterns and Examples
# =============================================================================

# Web Service Plugin Example:
# ---------------------------
# system_name: "web_api"
# connection:
#   protocol: "https"
#   host: "${API_HOST}"
#   port: 443
#   auth:
#     type: "token"
#     token: "${API_TOKEN}"
# monitoring:
#   metrics:
#     - name: "requests_per_second"
#       command: "get_rps"
#       unit: "req/s"
#       type: "float"
#     - name: "error_rate"
#       command: "get_error_rate"
#       unit: "percent"
#       type: "float"

# Database Plugin Example:
# ------------------------
# system_name: "postgres_db"
# connection:
#   protocol: "tcp"
#   host: "${DB_HOST}"
#   port: 5432
#   auth:
#     type: "basic"
#     username: "${DB_USER}"
#     password: "${DB_PASSWORD}"
# monitoring:
#   metrics:
#     - name: "active_connections"
#       command: "SELECT count(*) FROM pg_stat_activity"
#       unit: "count"
#       type: "integer"
#     - name: "query_duration"
#       command: "get_avg_query_time"
#       unit: "ms"
#       type: "float"

# Container/Kubernetes Plugin Example:
# ------------------------------------
# system_name: "k8s_deployment"
# connection:
#   protocol: "https"
#   host: "${K8S_API_SERVER}"
#   port: 6443
#   auth:
#     type: "certificate"
#     certificate_path: "${K8S_CERT_PATH}"
# execution:
#   actions:
#     - type: "SCALE_REPLICAS"
#       command: "kubectl scale deployment {name} --replicas={count}"
#       parameters:
#         - name: "name"
#           type: "string"
#           required: true
#         - name: "count"
#           type: "integer"
#           required: true
#           validation:
#             min: 1
#             max: 20

# =============================================================================
# Validation Guidelines and Common Errors
# =============================================================================

# Required Fields Checklist:
# - system_name: Must be unique and follow naming conventions
# - system_version: Must follow semantic versioning
# - implementation.connector_class: Must be importable Python class
# - connection.protocol: Must be supported by connector
# - monitoring.enabled: Must be boolean
# - execution.enabled: Must be boolean

# Common Configuration Errors:
# 1. Missing required fields - causes schema validation failure
# 2. Invalid connector_class - causes import errors during plugin loading
# 3. Unreachable host/port - causes connection failures during monitoring
# 4. Invalid metric commands - causes runtime errors during metric collection
# 5. Conflicting action preconditions - prevents actions from executing
# 6. Missing parameter validation - allows invalid action parameters

# Best Practices:
# 1. Use environment variables for sensitive data and deployment-specific values
# 2. Include comprehensive descriptions for all metrics and actions
# 3. Set appropriate timeouts and retry limits for system characteristics
# 4. Define meaningful preconditions to prevent unsafe operations
# 5. Use standard units and naming conventions for metrics
# 6. Test configuration thoroughly in development environment
# 7. Document any custom connector requirements or dependencies

# Framework Integration Notes:
# - Plugin configs are loaded by MonitorAdapter and ExecutionAdapter
# - Configuration changes require adapter restart to take effect
# - Invalid configurations prevent plugin loading and may affect system startup
# - Metric names become available for use in World Model analysis and Digital Twin queries
# - Action types become available for execution through Digital Twin recommendations
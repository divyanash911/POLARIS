# POLARIS Configuration for Failure Recovery Test Scenario
# This scenario tests detection and recovery from system failures

# Inherit from base mock system configuration
extends: "../mock_system_config.yaml"

# Override specific settings for failure recovery scenario
framework:
  service_name: "polaris-mock-system-failure-recovery"
  
managed_systems:
  mock_system:
    system_id: "mock_system_failure_recovery"
    
    # Very frequent monitoring for failure detection
    monitoring_config:
      collection_interval: 2  # Very frequent for failure detection
      health_check_interval: 5  # Frequent health checks
      
control_reasoning:
  threshold_reactive:
    # Aggressive failure detection and recovery rules
    rules:
      # Emergency scale-up for capacity failures
      - rule_id: "emergency_scale_up"
        name: "Emergency Capacity Scale Up"
        enabled: true
        priority: 5  # Highest priority
        cooldown_seconds: 15.0  # Very short cooldown for emergencies
        action_type: "SCALE_UP"
        conditions:
          - metric_name: "cpu_usage"
            operator: "gt"
            value: 95.0  # Critical CPU usage
            weight: 2.0
          - metric_name: "capacity"
            operator: "lt"
            value: 8
            weight: 0.5
            
      # Aggressive error rate recovery
      - rule_id: "high_error_rate_restart"
        name: "High Error Rate Emergency Restart"
        enabled: true
        priority: 5
        cooldown_seconds: 60.0  # Allow multiple restarts if needed
        action_type: "RESTART_SERVICE"
        conditions:
          - metric_name: "error_rate"
            operator: "gt"
            value: 3.0  # Very low threshold (3%)
            weight: 2.0
            
      # Critical response time recovery
      - rule_id: "critical_response_time_optimize"
        name: "Critical Response Time Recovery"
        enabled: true
        priority: 4
        cooldown_seconds: 20.0
        action_type: "OPTIMIZE_CONFIG"
        conditions:
          - metric_name: "response_time"
            operator: "gt"
            value: 800  # High threshold for critical situations
            weight: 1.5
            
      # Throughput failure recovery
      - rule_id: "throughput_failure_recovery"
        name: "Throughput Failure Recovery"
        enabled: true
        priority: 4
        cooldown_seconds: 30.0
        action_type: "ENABLE_CACHING"
        conditions:
          - metric_name: "throughput"
            operator: "lt"
            value: 10.0  # Very low throughput indicates failure
            weight: 2.0
            
      # Memory failure recovery
      - rule_id: "memory_failure_recovery"
        name: "Memory Failure Recovery"
        enabled: true
        priority: 4
        cooldown_seconds: 45.0
        action_type: "ADJUST_QOS"
        conditions:
          - metric_name: "memory_usage"
            operator: "gt"
            value: 5120  # High memory usage (5GB)
            weight: 1.5
            
      # Connection failure recovery
      - rule_id: "connection_failure_recovery"
        name: "Connection Failure Recovery"
        enabled: true
        priority: 3
        cooldown_seconds: 60.0
        action_type: "RESTART_SERVICE"
        conditions:
          - metric_name: "active_connections"
            operator: "lt"
            value: 2  # Very low connections indicate failure
            weight: 1.5
          - metric_name: "error_rate"
            operator: "gt"
            value: 1.0
            weight: 1.0
            
      # Cascading failure prevention
      - rule_id: "cascading_failure_prevention"
        name: "Cascading Failure Prevention"
        enabled: true
        priority: 5
        cooldown_seconds: 10.0  # Very short cooldown
        action_type: "SCALE_UP"
        conditions:
          - metric_name: "error_rate"
            operator: "gt"
            value: 5.0
            weight: 1.0
          - metric_name: "response_time"
            operator: "gt"
            value: 1000
            weight: 1.0
          - metric_name: "cpu_usage"
            operator: "gt"
            value: 90.0
            weight: 1.0

# Enhanced observability for failure analysis
observability:
  service_name: "polaris-mock-failure-recovery"
  metrics:
    collection_interval: 2   # Very frequent collection
    export_interval: 4       # Frequent export for failure analysis
  tracing:
    sample_rate: 1.0  # 100% sampling for failure analysis
  logging:
    log_level: "DEBUG"  # Detailed logging for failure analysis
    enable_correlation_ids: true

# Test scenario metadata
scenario:
  name: "failure_recovery"
  description: "Test detection and recovery from various system failures"
  expected_adaptations: 5-8
  duration_minutes: 20
  failure_simulation:
    failure_types:
      - "high_error_rate"
      - "memory_leak"
      - "cpu_spike"
      - "connection_drop"
      - "throughput_degradation"
    failure_timing:
      - minute: 3
        type: "high_error_rate"
        severity: "moderate"
      - minute: 7
        type: "cpu_spike"
        severity: "high"
      - minute: 12
        type: "memory_leak"
        severity: "critical"
      - minute: 16
        type: "connection_drop"
        severity: "moderate"
  success_criteria:
    - "All simulated failures detected within 30 seconds"
    - "Recovery actions triggered for each failure type"
    - "Service restarts executed for high error rates"
    - "Scale-up triggered for capacity failures"
    - "Configuration optimization applied for performance failures"
    - "System returns to stable state after each failure"
    - "No cascading failures occur"
    - "All recovery actions logged with details"